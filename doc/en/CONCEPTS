
1. TERMINAL ABSTRACT

First of all, it's good to know that nearly everything in tgt depends on things
contained in lowlevel/lowlevel.c file, that is routines to:

 - read terminal description from termcap and save useful for tgt data
   into an internal structure (tgt_terminal , see include/tgt_terminal.h):
     struct tgt_terminal * tgt_setscreen(char * terminal_description_name);
   This function also does some keyboard handling initializing, see somewhere
   else...
 - dispose terminal description, tgt_destroyterminal(struct tgt_terminal * term);
 - change terminal attributes, like colors, cursor position, etc:
    tgt_chattr(int attribute_code,int parama,int paramb);
   attribute codes are internal constants, like 
    tgt_chattr(TGT_TA_COLORS,TGT_COLOR_RED,TGT_COLOR_BLUE);

2. TGT OBJECTS CONCEPT

  Parts of GUI in TGT are called 'objects', and are described in a structure
called tgt_object (see include/tgt_classes.h), which contains, besides other
fields, x and y position and dimensions of object, a pointer to a function
which handles special things as rendering, handling keyboard for that object 
(an 'object class' function), and a void* pointer for everything that class
function wants to store. There's a limited number of built-in class functions,
each of them has its assigned constant (TGT_OBJECT_BUTTON, 
TGT_OBJECT_DESKTOP etc.) eg. for using in *createobject*() etc.
 

Each TGT object has its parent (ohwell, NULL parent is also a parent) and linked
list of children, first object on that list is the 'active' one, which means
it should be higlighted, and all keystrokes should be passed to it in the
first order (see below)

                        **********************
			* TGT_OBJECT_DESKTOP *
			**********************
			         |
		_______________________________________
	        |			              |
    +********************+                  +-------------------+
    * TGT_OBJECT_WINDOW  *                  | TGT_OBJECT_WINDOW |
    +********************+                  +-------------------+
                |                                     |
   ______________________________             ___________________
   |                            |             |     |           |
+-------------------+ *********************  +-+   +-+ +-------------------+
| TGT_OBJECT_BUTTON | * TGT_OBJECT_BUTTON *  | |   | | | TGT_OBJECT_STRING |
+-------------------+ *********************  +-+   +-+ +-------------------+

***** Active children
----- Inactive children


Object management functions are contained in classses/class.c and 
classes/management.c, using them you can create & destroy objects, link them
(assign a parent to an object/add a child to an object), unlink (remove an
object from its parent children list), make them active, refresh, etc.
As it was said, each kind of object has its handling function - those are
contained in classes/c_* (that functions are only for internal use, applications
using tgt might only use frontends).

3. KEYBOARD HANDLING

When a key-sequence generated by pressing one key (like 'q', PgUp, Esc, etc.)
is received by tgt keyhandling routines (which are started from application 
by tgt_waitkeys() or tgt_async_waitkeys()), it's 'delivered' to the 
active object on the lowest level of the object tree (in our example above,
to the active TGT_BUTTON_OBJECT). The key code (ASCII code or special values,
like TGT_KEY_INSERT) is being passed as an argument to class function, which 
pointer is contained in the tgt_object structure describing that object;
In other words, the class function is asked 'Do you recognize keycode ...?
If so, please do what you have to do when receiving it.' (note: the class
function needs also to recognize object switching keys (like tab) , but
this can be done in three lines by calling special functions from tgt for it)
If the class function does NOT recognize the keystroke, it's passed to the
active object (precisely speaking, to its class function) one level up (in our
example, TGT_OBJECT_WINDOW), until one of objects in tree recognizes it.

4. TAGLISTS

An object is created using a description contained in array of numbers
(sized same as pointers (!), ie on IA32 - integers), which is called a taglist.
Generally, there's a function (in classes/tags.c) to find a value of
specified tag in a taglist
(tgt_gettag(taglist,tag_code,what_to_return_if_not_found)), which is used
everywhere when it's needed to read a taglist in tgt (with one exception:
autolayout code), mainly in object initialization routines in class
functions (to read objects' initial parameters). Tag codes can also be used
to read/change objects attributes (tgt_get() & tgt_set()), if their class
functions support that.

