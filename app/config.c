#define PREFS_FILE
#include "tgt.h"
#include <pwd.h>
#include <sys/types.h>
#include <stdio.h>
#include <string.h>


static int tgt_conf_hash(char *str)
{
    int i,l,r;
    for(i=0,l=strlen(str),r=0;i<l;i++) r=(r << 1) + str[i];
    return(r % HASH_SIZE);
}

struct tgt_value
{
    struct tgt_value *next;
    char *key;
    char *string;
};

struct tgt_section
{
    struct tgt_section *next;
    char *name;
    struct tgt_value * pairs[HASH_SIZE];
};

struct tgt_prefs
{
    struct tgt_section * sections[HASH_SIZE];
};

char* tgt_get_conf(struct tgt_prefs *prefs,char *section,char *key,char *def)
{
    struct tgt_section *sec;
    struct tgt_value *pair;
    int k;
    if(!prefs) return(def);
    k=tgt_conf_hash(section); for(sec=prefs->sections[k];sec!=NULL;sec=sec->next) if(strcmp(section,sec->name)==0) break;
    if(!sec) return(def);
    k=tgt_conf_hash(key); for(pair=sec->pairs[k];pair!=NULL;pair=pair->next) if(strcmp(key,pair->key)==0) break;
    if(!pair) return(def);
    return(pair->string);
}

int tgt_set_conf(struct tgt_prefs *prefs,char* section,char* key,char* value)
{
    int k,ret,i;
    struct tgt_section *sec;
    struct tgt_value *pair;
    k=tgt_conf_hash(section); ret=0;
    for(sec=prefs->sections[k];sec!=NULL;sec=sec->next) if(strcmp(section,sec->name)==0) break;
    if(!sec)
    {
	ret|=CONF_NOTICE_NOSUCHSECTION;
	sec=(struct tgt_section*) malloc(sizeof(struct tgt_section));
	sec->name=strdup(section);
	sec->next=prefs->sections[k];
	for(i=0;i<HASH_SIZE;i++) sec->pairs[i]=NULL;
	prefs->sections[k]=sec;
    }
    k=tgt_conf_hash(key);
    for(pair=sec->pairs[k];pair!=NULL;pair=pair->next) if(strcmp(key,pair->key)==0) break;
    if(!pair)
    {
	ret|=CONF_NOTICE_NOSUCHKEY;
	pair=(struct tgt_value*) malloc(sizeof(struct tgt_value));
	pair->key=strdup(key);
	pair->next=sec->pairs[k];
	sec->pairs[k]=pair;
    }
    else
	free(pair->string);

    pair->string=strdup(value);

/*    printf("assignement in '%s': '%s' ==== '%s'\n",section,key,value);*/
    return(ret);
}

unsigned char *tgt_reparse(unsigned char *string)
{
    unsigned char *ret;
    unsigned char c,d,e;
    int l,i,k;
    
    l=strlen(string);
    ret=(unsigned char*) malloc(l*4+2);
    for(i=0,k=0;i<l;i++)
    {
	c=string[i];
	if(!isprint(c))
	{
	    d=c >> 4; e=c & 0xf;
	    if(d<10) d+='0'; else d=d+'a'-10;
	    if(e<10) e+='0'; else e=e+'a'-10;
	    ret[k++]='\\'; ret[k++]='x'; ret[k++]=d; ret[k++]=e;
	}
	else
	{
	    if(c=='\\' || c=='"')
	    {
		ret[k++]='\\'; ret[k++]=c;
	    }
	    else
		ret[k++]=c;
	}
    }
    ret[k++]=0;
    return(ret);
}

unsigned char *tgt_parse(unsigned char *string,int *length,unsigned char terminator)
{
    unsigned char *out;
    unsigned char c,d,e;
    int i,k;
    out=(char*) malloc(strlen(string)); k=0;
    for(i=0;string[i]!=0;i++)
    {
	if(string[i]=='\\')
	{
	    c=string[i+1];
	    if(!c) continue;
	    if(c=='x')
	    {
	        if(d=string[i+2])
	        {
	    	    if(e=string[i+3])
		    {
		        if(d>='a' && d<='f') d=d-'a'+10; else d-='0';
		        if(e>='a' && e<='f') e=e-'a'+10; else e-='0';
		        out[k++]=d << 4 | e;
			i+=3; continue;
		    }
		}
	    }
	     out[k++]=c; i++;
	}
	else
	{
	    if(string[i]==terminator) break;
	    out[k++]=string[i];
	}
    }
    out[k]=0;
    if(length) *length=i;
    return(out);
}

char * tgt_compressstr(char *a)
{
    int i,k,l;
    char *ret;
    ret=(char*) malloc(l=strlen(a));
    for(i=0,k=0;i<l;i++) if(!isspace(a[i])) ret[k++]=a[i];
    ret[k]=0; return(ret);
}

void tgt_unload_conf(struct tgt_prefs * prefs)
{
    int i,j;
    struct tgt_section *a,*p;
    struct tgt_value *b,*q;
    for(i=0;i<HASH_SIZE;i++)
    {
	for(a=prefs->sections[i];a;a=p)
	{	
	    for(j=0;j<HASH_SIZE;j++)
	    {
		for(b=a->pairs[j];b;b=q)
		{
		    q=b->next;
		    free(b->key);
		    free(b->string);
		    free(b);
		}
	    }
	    p=a->next;
	    free(a->name);
	    free(a);
	}
    }
    free(prefs);
}

int tgt_save_conf(struct tgt_prefs * prefs,char *filename)
{
    int i,j;
    char *str;
    FILE *fh;
    struct tgt_section *a;
    struct tgt_value *b;
    
    if(!(fh=fopen(filename,"w"))) return(0);
    fprintf(fh,"# Auto-generated by config.o/libtgt.so , Written 2000 by Thomas Sterna & Matthew Golicz\n");
    
    for(i=0;i<HASH_SIZE;i++)
	for(a=prefs->sections[i];a;a=a->next)
	{	
	    fprintf(fh,"[%s]\n",a->name);
	    for(j=0;j<HASH_SIZE;j++)
		for(b=a->pairs[j];b;b=b->next)
		{
		    fprintf(fh,"%s = \"%s\"\n",b->key,str=tgt_reparse(b->string));
		    free(str);
		}
	}

    fclose(fh);
    return(1);
}


struct tgt_prefs * tgt_load_conf(char *name)
{
    FILE *fh;
    char *file,*mem,*hdir;
    struct tgt_prefs *ret;
    int i,j,size,seclen,keylen,l;
    char *section;
    char *value,*key;
    struct passwd *pentry;
    
    ret=(struct tgt_prefs*) malloc(sizeof(struct tgt_prefs));
    for(i=0;i<HASH_SIZE;i++) ret->sections[i]=NULL;
    
    if(!(fh=fopen(name,"r")))
    {
	if(pentry=getpwuid(getuid()))
	    if(hdir=pentry->pw_dir)
	    {
		file=(char*) malloc(strlen(hdir)+strlen(name)+2);
		sprintf(file,"%s/%s",hdir,name);
		fh=fopen(file,"r");
		free(file);
	    }
	if(!fh)
	{
	    file=(char*) malloc(strlen(name)+6);
	    sprintf(file,"/etc/%s\n",name);
	    fh=fopen(file,"r");
	    free(file);
	    if(!fh) return(ret);
	}
    }

    fseek(fh,0,SEEK_END); size=ftell(fh); rewind(fh);
    mem=file=(char*) malloc(size+1); file[size]=0;
    fread(file,size,1,fh); 
    fclose(fh);

    section=strdup("main");
    for(;;)
    {
	for(;isblank(*file) || *file=='\n' || *file=='\r';file++); if(!(*file)) break;
 	if(*file=='#') if(!(file=index(file,'\n'))) break;
	if(*file=='[') /* New section */
	{
	    for(seclen=0;file[seclen]!=']' && file[seclen]!=0;seclen++);
	    if(!(file[seclen]))
	    {
		fprintf(stderr,"tgt_load_conf(): Parse error: unable to find matching ']'\n");
		break;
	    }
	    if(section) free(section);
	    section=(char*) malloc(seclen);
	    snprintf(section,seclen,"%s",file+1);
	    file+=seclen+1;
	    continue;
	}
	/* Assignement then */
        for(keylen=0;file[keylen]!='=' && file[keylen]!=0;keylen++); if(file[keylen]==0) break;
	key=file; key[keylen]=0; file+=keylen+1;
	for(i=0;isblank(file[i]);i++);
	if(file[i]=='"') 
	{
	    value=tgt_parse(file+i+1,&l,'"');
	    if(file[i+1]==0 || file[i+2]==0) break;
	    file+=l+i+2;
	}
	else
	{
	    value=tgt_parse(file,&l,'\n');
	    file+=l;
	}
	    
	key=tgt_compressstr(key);
	tgt_set_conf(ret,section,key,value);
	free(value); free(key);
    }
    free(mem); free(section);
    return(ret);
}

void * g_prefs;

extern int d_seconds,d_micros;
void tgt_init(void)
{
    g_prefs=(void*) tgt_load_conf(".tgtrc");
    d_seconds=atoi(tgt_getprefs((struct tgt_prefs*) g_prefs,"keyboard","esc_sec","0"));
    d_micros=atoi(tgt_getprefs((struct tgt_prefs*) g_prefs,"keyboard","esc_usec","200000"));
}

